#!/usr/bin/env python
import yaml
import sys
import os
import xml.etree.cElementTree as ET
from subprocess import call 
from os import walk
from shutil import copyfile
import re

ESROCOS_YAML = "esrocos.yml"
ROOT_DIR = os.environ['AUTOPROJ_CURRENT_ROOT']

project_name = ""
SRC_DIR = ""
INSTALL_DIR = ""
LOCAL_PROJECT = False

# READ YAML

print "read esrocos.yml...",

data = []

try:
  with open(ESROCOS_YAML, 'r') as infile:

    data = yaml.load(infile)
    project_name = data["PROJECT_NAME"]
    SRC_DIR = data["ASNACN_DIR"]
    INSTALL_DIR = data["INSTALLED_TYPES_DIR"]
    LOCAL_PROJECT = data["LOCAL_PROJECT"]
  
except IOError:
  print "could not read esrocos.yml, aborting..."
  sys.exit()
except KeyError:
  print "error parsing esrocos.yml, aborting..."
  sys.exit()

print "DONE"


 
# EXTRACT OSDEPS

try:
  os_deps = data['os_deps']
except KeyError as err:
  print "error in reading yml data, aborting..."
  sys.exit()
  
# EXTRACT LOCAL AND REMOTE PKG DEPS

try:
  pkg_deps = data['pkg_deps']
except KeyError as err:
  print "error in reading yml data, aborting..."
  sys.exit()

if LOCAL_PROJECT:

  # GENERATE LOCAL manifest.xml
  print "generate manifest.xml",

  package = ET.Element("package")

  # generate entries for all packages to force package existence at compile time
  for dep in pkg_deps:
    for key in dep:
      if not dep[key]:
        ET.SubElement(package, "depend", package=key)   

  for dep in os_deps:
    ET.SubElement(package, "depend", package=dep)
  
  manifest = ET.ElementTree(package)
  manifest.write("manifest.xml")

  print "DONE" 


  # ADVERTISE LOCAL DEPS IN LOCAL.AUTOBUILD 
  # ADVERTISE REMOTE DEPS IN UNIVERSE PACKAGE SET

  localpath = ROOT_DIR+"/autoproj/"+project_name+".autobuild"
  remotepath = ROOT_DIR+"/autoproj/remotes/esrocos.universe/"+project_name+".autobuild"

  try:
    with open(localpath, 'w') as localout, open(remotepath, 'w') as remoteout:
      localout.write('import_package "'+project_name+'"\n')
      for dep in pkg_deps:
        name = ''
        remote = False
        for key in dep: 
          if key == 'github':
            remote = True
          if not dep[key]:
            name = key
        if remote:
          remoteout.write('import_package "'+name+'"\n')
        else:
          localout.write('import_package "'+name+'"\n') 

  except IOError as err:
    print "could not write to file, exit..."
    sys.exit()
 
  print "DONE"

  # GENERATE SOURCE ENTRIES FOR REMOTE DEPS
  print "trying to open existing source.yml"

  #open universe source.yml

  path = ROOT_DIR+"/autoproj/remotes/esrocos.universe/source.yml"
  data = {}

  try:
    with open(path, 'r') as sources:
      print "parsing source.yml data"
      data = yaml.load(sources)
      if not data['version_control']:
        data['version_control'] = []
  except IOError as err:
    print "did not find existing source.yml..."
    data = {'version_control':[]}

  # create hash map of existing entries to avoid doubles

  existing_deps = {}
  for dep in data['version_control']:
    for key in dep:
      if not dep[key]:
        existing_deps[key] = True

  # manipulate source.yml data

  for dep in pkg_deps:
    name = ''
    remote = False

    for key in dep:  
      if key == 'github':
        remote = True
      if not dep[key]:
        name = key   
  
    if remote and not existing_deps[name]:
      data['version_control'].append(dep)

  # write back to source.yml
  try:
    with open(path, 'w') as outfile:
      yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)
  except IOError as err:
    print "could not write to file, aborting..."
    sys.exit()

#ENDIF LOCAL_PROJECT 

# AUP
print "calling aup...\t", 
sys.stdout.flush()

aup_arguments = ["autoproj","update"]

call(aup_arguments)

print "DONE"

# REMOVE OLD FILES AND RESET CHANGES

#print "clean tmp files...",

#remote_autobuild_path = os.environ['AUTOPROJ_CURRENT_ROOT']+"/autoproj/remotes/esrocos.universe/"+project_name+".autobuild"
#local_autobuild_path = os.environ['AUTOPROJ_CURRENT_ROOT']+"/autoproj/"+project_name+".autobuild"
#manifest_path = "manifest.xml"

#os.remove(manifest_path)
#os.remove(local_autobuild_path)
#os.remove(remote_autobuild_path)

#print "DONE"

# COPY ASN FILES FROM SHARED DIR TO LOCAL INSTALL DIR

# create hash map of packages to copy from

deps_map = {}

for dep in pkg_deps:
  for key in dep:
     if not dep[key]:
       try: 
         match = key.rsplit('/',1)[-1]
         deps_map[match] = True
       except AttributeError:
         print "no match"            

# walk directories and copy files
print "locally installing shared types...\t", 
sys.stdout.flush()

SHARED_TYPES_DIR = ROOT_DIR+"/install/types/"

# walk through each directory in the installed types
dirs = []

for (dirpath, dirnames, filenames) in walk(SHARED_TYPES_DIR):
  dirs.extend(dirnames)
  break

for dirname in dirs:

# proceed only if dir is the name of a dependency
  try:
    if not deps_map[dirname]:
      continue
  except KeyError:
    continue

# create install dir for dependency 
  try:
    os.makedirs(INSTALL_DIR+dirname+"/asn")
  except OSError as err:
    if not err.errno == 17: 
      raise err  

# walk files in directory

  for (dirpath, dirnames, filenames) in walk(SHARED_TYPES_DIR+"/"+dirname+"/asn"):
    for filename in filenames:
      try:
        copyfile(dirpath+"/"+filename,INSTALL_DIR+dirname+"/asn/"+filename)
      except IOError as err:
        raise err

print "DONE"

# COMPILE ASN AND ACN TO MONOLITHIC AADL FILE

#getting asn and acn files from folder

asn_acn_files = []
asn_filenames = []

for (dirpath, dirnames, filenames) in walk(SRC_DIR):
  for filename in filenames:
    if filename.endswith(".asn") or filename.endswith(".acn"):
      if not filename in asn_filenames:
        asn_acn_files.append(os.getcwd()+"/"+os.path.join(dirpath,filename))
        asn_filenames.append(filename)
      else: 
        print "duplicate: "+filename

for (dirpath, dirnames, filenames) in walk(INSTALL_DIR):
  for filename in filenames:
    if filename.endswith(".asn") or filename.endswith(".acn"):
      if not filename in asn_filenames:
        asn_acn_files.append(os.getcwd()+"/"+os.path.join(dirpath,filename))
        asn_filenames.append(filename)
      else: 
        print "duplicate: "+filename

#print asn_acn_files

asn_arguments = ["asn2aadlPlus"]
asn_arguments.extend(asn_acn_files)
asn_arguments.append(os.getcwd()+ "/" + INSTALL_DIR + project_name.replace(" ", "_") + "_dv.aadl")

call(asn_arguments)

